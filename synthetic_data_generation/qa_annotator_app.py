#!/usr/bin/env python3
"""
Q&A Annotation Tool - Streamlit Web Application

This tool provides a web-based interface for annotating Q&A pairs generated by the synthetic data generation system.
It allows users to review, pass, fail, or skip Q&A pairs and export the results.

Usage:
    streamlit run qa_annotator_app.py [input_directory]
    
    If no input_directory is provided, it defaults to "data/q-a"

Features:
- Web-based annotation interface with file selection dropdown
- Directory-based file management
- Progress tracking
- Comments for each annotation
- Export functionality for vetted data
- Session state persistence
"""

import streamlit as st
import json
import os
import datetime
import textwrap
from pathlib import Path
import sys


class QAAnnotatorApp:
    def __init__(
            self,
            input_dir: str = 'data/q-a',
            output_dir: str = "data/q-a-vetted",
            vetted_dir: str = "data/q-a-vetted"
        ):
        self.input_dir = Path(input_dir)
        self.qa_dir = output_dir
        self.vetted_dir = Path(vetted_dir)
        
        # Ensure directories exist
        self.vetted_dir.mkdir(parents=True, exist_ok=True)
        
        # Initialize session state
        if 'qa_data' not in st.session_state:
            st.session_state.qa_data = []
        if 'current_index' not in st.session_state:
            st.session_state.current_index = 0
        if 'annotations' not in st.session_state:
            st.session_state.annotations = []
        if 'source_file' not in st.session_state:
            st.session_state.source_file = None
        if 'available_files' not in st.session_state:
            st.session_state.available_files = []
    
    def scan_input_directory(self):
        """Scan input directory for JSON files"""
        try:
            json_files = []
            if self.input_dir.exists():
                json_files = [f.name for f in self.input_dir.glob("*.json")]
                json_files.sort()  # Sort alphabetically
            st.session_state.available_files = json_files
            return json_files
        except Exception as e:
            st.error(f"Error scanning directory: {e}")
            return []
    
    def load_qa_data(self, filename):
        """Load Q&A data from file in the input directory"""
        try:
            file_path = self.input_dir / filename
            with open(file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            st.session_state.qa_data = data
            st.session_state.source_file = filename
            st.session_state.current_index = 0
            st.session_state.annotations = [None] * len(data)
            return True
        except Exception as e:
            st.error(f"Error loading file: {e}")
            return False
    
    def get_annotation_summary(self):
        """Get summary of current annotations"""
        annotations = st.session_state.annotations
        passing = sum(1 for a in annotations if a and a['status'] == 'pass')
        failing = sum(1 for a in annotations if a and a['status'] == 'fail')
        skipped = sum(1 for a in annotations if a and a['status'] == 'skip')
        total = len(st.session_state.qa_data)
        annotated = passing + failing + skipped
        
        return {
            'passing': passing,
            'failing': failing,
            'skipped': skipped,
            'total': total,
            'annotated': annotated,
            'completion_rate': (annotated / total * 100) if total > 0 else 0
        }
    
    def annotate_current_item(self, status, comments=""):
        """Annotate the current item"""
        if not st.session_state.qa_data:
            return
        
        current_idx = st.session_state.current_index
        annotation = {
            'index': current_idx,
            'status': status,
            'comments': comments.strip(),
            'timestamp': datetime.datetime.now().isoformat()
        }
        
        st.session_state.annotations[current_idx] = annotation
    
    def get_passing_items(self):
        """Get all items marked as passing"""
        passing_items = []
        for i, annotation in enumerate(st.session_state.annotations):
            if annotation and annotation['status'] == 'pass':
                item = st.session_state.qa_data[i].copy()
                item['annotation'] = annotation
                passing_items.append(item)
        return passing_items
    
    def save_results(self):
        """Save annotation results to files"""
        if not st.session_state.qa_data:
            st.error("No data to save!")
            return False
        
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # Save passing items
        passing_items = self.get_passing_items()
        if passing_items:
            vetted_filename = f"qa_vetted_{timestamp}.json"
            vetted_filepath = self.vetted_dir / vetted_filename
            
            with open(vetted_filepath, 'w', encoding='utf-8') as f:
                json.dump(passing_items, f, ensure_ascii=False, indent=2)
        
        # Save annotation log
        summary = self.get_annotation_summary()
        log_filename = f"annotation_log_{timestamp}.json"
        log_filepath = self.vetted_dir / log_filename
        
        annotation_log = {
            'source_file': st.session_state.source_file,
            'total_items': len(st.session_state.qa_data),
            'annotations': st.session_state.annotations,
            'summary': summary
        }
        
        with open(log_filepath, 'w', encoding='utf-8') as f:
            json.dump(annotation_log, f, ensure_ascii=False, indent=2)
        
        st.success(f"âœ… Saved {len(passing_items)} passing items to: {vetted_filename}")
        st.success(f"ğŸ“ Saved annotation log to: {log_filename}")
        return True
    
    def display_current_item(self):
        """Display the current Q&A item"""
        if not st.session_state.qa_data:
            st.warning("No data loaded. Please select a file first.")
            return
        
        current_idx = st.session_state.current_index
        if current_idx >= len(st.session_state.qa_data):
            st.success("ğŸ‰ All items have been reviewed!")
            return
        
        item = st.session_state.qa_data[current_idx]
        
        # Progress indicator
        total = len(st.session_state.qa_data)
        progress = (current_idx + 1) / total
        st.progress(progress, text=f"Item {current_idx + 1} of {total}")
        
        # Display Q&A pair
        st.subheader(f"Q&A Pair #{current_idx + 1}")

        # Tags (if available)
        if 'tags' in item and item['tags']:
            tags = ', '.join(f"`{k}: {v}`" for k, v in item['tags'].items())
            st.markdown(f"**ğŸ·ï¸ TAGS:** {tags}")

        # Question
        st.markdown("**ğŸ” QUESTION:**")
        st.markdown(f"> {item['question']}")
        
        # Answer
        st.markdown("**âœ… ANSWER:**")
        st.markdown(f"> {item['answer']}")
        
        # Chunk content
        st.markdown("**ğŸ“„ CHUNK CONTENT:**")
        for j, chunk in enumerate(item.get('chunk_content', []), 1):
            with st.expander(f"Chunk {j}"):
                cleaned_chunk = chunk.replace('\n', ' ').replace('\r', '').strip()
                st.text(textwrap.fill(cleaned_chunk, width=80))
        
        # Show current annotation status if exists
        current_annotation = st.session_state.annotations[current_idx]
        if current_annotation:
            st.info(f"ğŸ“ Annotation: **{current_annotation['status'].upper()}**")
            if current_annotation.get('comments'):
                st.info(f"ğŸ’¬ Comments: {current_annotation['comments']}")
    
    def render_annotation_controls(self):
        """Render annotation control buttons and comments"""
        if not st.session_state.qa_data:
            return
        
        current_idx = st.session_state.current_index
        
        # Comments text area
        current_annotation = st.session_state.annotations[current_idx]
        existing_comments = current_annotation.get('comments', '') if current_annotation else ''
        
        comments = st.text_area(
            "Comments (optional):",
            value=existing_comments,
            placeholder="Add comments about this Q&A pair...",
            height=100
        )
        
        # Action buttons
        col1, col2, col3 = st.columns(3)
        
        with col1:
            if st.button("âœ… Pass", type="secondary", use_container_width=True):
                self.annotate_current_item('pass', comments)
                st.rerun()
        
        with col2:
            if st.button("âŒ Fail", type="secondary", use_container_width=True):
                self.annotate_current_item('fail', comments)
                st.rerun()
        
        with col3:
            if st.button("â­ï¸ Skip", type="secondary", use_container_width=True):
                self.annotate_current_item('skip', comments)
                st.rerun()
        
        # Navigation buttons
        st.markdown("---")
        col1, col2, col3 = st.columns([1, 2, 1])
        
        with col1:
            if st.button("â¬…ï¸ Previous", disabled=(current_idx == 0)):
                if current_idx > 0:
                    st.session_state.current_index -= 1
                    st.rerun()
        
        with col2:
            if st.button("ğŸ’¾ Save Annotations", type="primary", use_container_width=True):
                self.save_results()
        
        with col3:
            if st.button("â¡ï¸ Next", disabled=(current_idx >= len(st.session_state.qa_data) - 1)):
                if current_idx < len(st.session_state.qa_data) - 1:
                    st.session_state.current_index += 1
                    st.rerun()
    
    def render_sidebar(self):
        """Render sidebar with file selection and summary"""
        st.sidebar.title("Q&A Annotation Tool")
        
        # Directory info
        st.sidebar.subheader("Data Directory")
        st.sidebar.text(f"Input Dir: {self.input_dir}")
        
        # File selection
        st.sidebar.subheader("File Selection")
        
        # Scan for available files
        if st.sidebar.button("ğŸ”„ Refresh Files"):
            self.scan_input_directory()
            st.rerun()
        
        # Get available files
        available_files = self.scan_input_directory()
        
        if available_files:
            selected_file = st.sidebar.selectbox(
                "Select JSON file:",
                options=[""] + available_files,
                index=0,
                help="Choose a Q&A JSON file to annotate"
            )
            
            if selected_file and st.sidebar.button("ğŸ“‚ Load Selected File", type="primary"):
                if self.load_qa_data(selected_file):
                    st.sidebar.success(f"âœ… Loaded {len(st.session_state.qa_data)} items")
                    st.rerun()
        else:
            st.sidebar.warning("âš ï¸ No JSON files found in the input directory")
            st.sidebar.info("Make sure your input directory contains JSON files with Q&A data.")
        
        # Summary
        if st.session_state.qa_data:
            st.sidebar.subheader("Progress Summary")
            summary = self.get_annotation_summary()
            
            st.sidebar.metric("Total Items", summary['total'])
            st.sidebar.metric("Completion Rate", f"{summary['completion_rate']:.1f}%")
            
            col1, col2 = st.sidebar.columns(2)
            with col1:
                st.metric("âœ… Passing", summary['passing'])
                st.metric("â­ï¸ Skipped", summary['skipped'])
            with col2:
                st.metric("âŒ Failing", summary['failing'])
                st.metric("ğŸ“ Annotated", summary['annotated'])
            
            # Save button
            st.sidebar.markdown("---")
            if st.sidebar.button("ğŸ’¾ Save Results", type="primary"):
                self.save_results()
    
    def run(self):
        """Main application runner"""
        st.set_page_config(
            page_title="Q&A Annotation Tool",
            page_icon="ğŸ“",
            layout="wide"
        )
        
        # Render sidebar
        self.render_sidebar()
        
        # Main content
        st.title("ğŸ“ Q&A Annotation Tool")
        
        if not st.session_state.qa_data:
            st.info("ğŸ‘ˆ Please select a file from the sidebar to begin annotation.")
        else:
            # Display current item
            self.display_current_item()
            
            # Show annotation controls
            st.markdown("---")
            self.render_annotation_controls()

def main():
    """Main entry point for the annotation app"""
    
    # Check if running with streamlit
    if 'streamlit' not in sys.modules:
        print("\n" + "="*60)
        print("Q&A ANNOTATION TOOL")
        print("="*60)
        print("\nThis is a Streamlit web application.")
        print("To run it properly, use one of these commands:")
        print("\n1. Using streamlit directly:")
        print("   streamlit run run_annotation_app.py")
        print("\n2. From the synthetic_data_generation directory:")
        print("   cd synthetic_data_generation")
        print("   streamlit run run_annotation_app.py")
        print("\n3. With full path:")
        print(f"   streamlit run \"{os.path.abspath(__file__)}\"")
        print("\nThis will open the annotation tool in your web browser.")
        print("="*60)
        return
    
    # Initialize and run the app
    app = QAAnnotatorApp()
    app.run()

if __name__ == "__main__":
    main()

